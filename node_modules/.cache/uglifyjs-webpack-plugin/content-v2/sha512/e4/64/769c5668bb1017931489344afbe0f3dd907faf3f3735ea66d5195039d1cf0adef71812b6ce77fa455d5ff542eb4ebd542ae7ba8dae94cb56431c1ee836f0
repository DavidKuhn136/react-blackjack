{"map":"{\"version\":3,\"sources\":[\"c:/Projects/React/react-blackjack/app\\\\reducer.js\"],\"names\":[\"_immutable\",\"__webpack_require__\",\"_cards\",\"setupGame\",\"currentState\",\"playerHand\",\"deck\",\"newDeck\",\"dealerHand\",\"_deal\",\"deal\",\"_deal2\",\"_slicedToArray\",\"_deal3\",\"_deal4\",\"push\",\"Map\",\"newState\",\"hasStood\",\"merge\",\"setRecord\",\"wins\",\"losses\",\"winCount\",\"lossCount\",\"arguments\",\"length\",\"undefined\",\"action\",\"type\"],\"mappings\":\"2hBAAAA,EAAAC,EAAA,IAEAC,EAAAD,EAAA,+BAEA,QAAME,EAAY,SAACC,GAChB,IACIC,EADAC,GAAO,EAAAJ,EAAAK,WACKC,OAAAA,EAFiBC,GAIZ,EAAAP,EAAAQ,MAAKJ,EAAM,GAJCK,EAAAC,EAAAH,EAAA,GAIhCH,EAJgCK,EAAA,GAI1BN,EAJ0BM,EAAA,GAAA,IAAAE,GAKZ,EAAAX,EAAAQ,MAAKJ,EAAM,GALCQ,EAAAF,EAAAC,EAAA,GAKhCP,EALgCQ,EAAA,GAOjCN,GAFOA,EAL0BM,EAAA,IAOTC,KAAK,IAAAf,EAAAgB,KAE7B,IAEMC,EAAW,IAAAjB,EAAAgB,KAAUV,KAAAA,EAAMD,WAAAA,EAAYG,WAAAA,EAAYU,UAFxC,IAIjB,OAAOd,EAAae,MAAMF,IAGvBG,EAAY,SAAChB,EAAciB,EAAMC,GACpC,OAAOlB,EAAae,MAAM,IAAAnB,EAAAgB,KAAUO,SAAYF,EAAMG,UAAaF,QAGvD,WAAyC,IAAhClB,EAAgCqB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAnB,IAAAzB,EAAAgB,IAAWY,EAAQH,UAAA,GACrD,OAAOG,EAAOC,MACV,IAAK,aACD,OAAO1B,EAAUC,GACrB,IAAK,aACD,OAAOgB,EAAUhB,EAAcwB,EAAOP,KAAMO,EAAON,QAE3D,OAAOlB,gEA3BJD,6EAgBAiB\",\"sourcesContent\":[\"import { Map } from 'immutable';\\r\\n\\r\\nimport { newDeck, deal } from './lib/cards';\\r\\n\\r\\nconst setupGame = (currentState) => {\\r\\n   let deck = newDeck();\\r\\n   let playerHand, dealerHand;\\r\\n\\r\\n   [deck, playerHand] = deal(deck, 2);\\r\\n   [deck, dealerHand] = deal(deck, 1);\\r\\n\\r\\n   dealerHand = dealerHand.push(new Map());\\r\\n\\r\\n   const hasStood = false;\\r\\n\\r\\n   const newState = new Map({ deck, playerHand, dealerHand, hasStood });\\r\\n\\r\\n   return currentState.merge(newState);\\r\\n};\\r\\n\\r\\nconst setRecord = (currentState, wins, losses) => {\\r\\n   return currentState.merge(new Map({ \\\"winCount\\\": wins, \\\"lossCount\\\": losses }));\\r\\n}\\r\\n\\r\\nexport default function(currentState=new Map(), action) {\\r\\n   switch(action.type) {\\r\\n       case 'SETUP_GAME':\\r\\n           return setupGame(currentState);\\r\\n       case 'SET_RECORD':\\r\\n           return setRecord(currentState, action.wins, action.losses);\\r\\n   }\\r\\n   return currentState;\\r\\n}\\r\\n\"]}","code":"webpackHotUpdate(0,{33:function(e,r,t){\"use strict\";(function(e){Object.defineProperty(r,\"__esModule\",{value:!0});var a,n=function(){return function(e,r){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,r){var t=[],a=!0,n=!1,c=void 0;try{for(var u,o=e[Symbol.iterator]();!(a=(u=o.next()).done)&&(t.push(u.value),!r||t.length!==r);a=!0);}catch(e){n=!0,c=e}finally{try{!a&&o.return&&o.return()}finally{if(n)throw c}}return t}(e,r);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),c=t(12),u=t(32);(a=t(0).enterModule)&&a(e);var o,i,l=function(e){var r,t=(0,u.newDeck)(),a=void 0,o=(0,u.deal)(t,2),i=n(o,2);t=i[0],r=i[1];var l=(0,u.deal)(t,1),s=n(l,2);t=s[0],a=(a=s[1]).push(new c.Map);var d=new c.Map({deck:t,playerHand:r,dealerHand:a,hasStood:!1});return e.merge(d)},s=function(e,r,t){return e.merge(new c.Map({winCount:r,lossCount:t}))},d=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new c.Map,r=arguments[1];switch(r.type){case\"SETUP_GAME\":return l(e);case\"SET_RECORD\":return s(e,r.wins,r.losses)}return e};r.default=d,o=t(0).default,i=t(0).leaveModule,o&&(o.register(l,\"setupGame\",\"c:/Projects/React/react-blackjack/app/reducer.js\"),o.register(s,\"setRecord\",\"c:/Projects/React/react-blackjack/app/reducer.js\"),o.register(d,\"default\",\"c:/Projects/React/react-blackjack/app/reducer.js\"),i(e))}).call(this,t(3)(e))}});","extractedComments":[]}